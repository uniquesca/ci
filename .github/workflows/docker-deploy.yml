name: Deploy

on:
  workflow_call:
    secrets:
      SSH_KEY:
        description: 'SSH private key to use to connect to the host'
        required: true
      UNIQUES_GITHUB_ACCESS_TOKEN:
        description: 'Access token for cloning Uniques private repositories from GitHub'
        required: true
      NODE_AUTH_TOKEN:
        description: 'Access token for authentication with the NPM registry'
        required: false
      ENV_VARIABLES:
        description: 'Environment variables to set on the remote server'
        required: false
    inputs:
      host:
        description: 'Address of the server'
        required: true
        type: string
      username:
        description: 'SSH login'
        required: true
        type: string
      port:
        description: 'SSH password'
        required: false
        default: '22'
        type: string
      deployment_path:
        description: 'Working directory of the project on the server'
        required: true
        type: string
      ref:
        description: 'Git branch or tag to use for the project on the server'
        required: true
        type: string
      mode:
        description: 'Can be pull, build or skip it otherwise'
        required: false
        type: string
      docker_up_args:
        description: 'Arguments to pass to docker up command'
        required: false
        type: string
        default: '--force-recreate'
      runner_pre_cmd:
        description: 'Command to execute on the RUNNER before preparing the environment. Used ONLY if prepare_environment is set to true.'
        required: false
        default: ''
        type: string
      post_cmd:
        description: 'Command to execute on the REMOTE after deployment is complete'
        required: false
        default: ''
        type: string
      prepare_environment:
        description: 'Flag whether environment configs should be processed'
        required: false
        default: true
        type: boolean
jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout application repository
        uses: actions/checkout@v4
        if: ${{ inputs.prepare_environment }}
        with:
          ref: ${{ inputs.ref }}

      - name: Pre-process command
        if: ${{ inputs.prepare_environment }}
        run: |
          ${{ inputs.runner_pre_cmd }}

      # This has to be done before the configs are uploaded
      - name: Initialize deployment environment if necessary
        uses: appleboy/ssh-action@v1
        id: initialize
        with:
          host: ${{ inputs.host }}
          username: ${{ inputs.username }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ inputs.port }}
          command_timeout: 5m
          capture_stdout: true
          script: |
            # Making it more strict for the script to fail in case of an error
            set -eux;
            
            # Check if it's already a git repo
            if [ ! -d "${{ inputs.deployment_path }}/.git" ]; then
              echo "Git not initialized, cloning repository..."
              git clone "git@github.com:${{ github.repository }}.git" "${{ inputs.deployment_path }}"
              cd "${{ inputs.deployment_path }}"
              git checkout "${{ inputs.ref }}""
              echo "<<<OUTPUT::0>>>"
            else
              echo "<<<OUTPUT::1>>>"
            fi

      - name: Process configs
        if: ${{ inputs.prepare_environment }}
        uses: uniquesca/ci/prepare-environment@main
        with:
          env_variables: ${{ secrets.ENV_VARIABLES }}

      - name: Prepare upload paths
        id: upload_paths
        run: |
          PATHS=$(jq -r '[.configs[].path] | join(",")' _ci_environment.json)
          echo "paths=$PATHS" >> $GITHUB_OUTPUT

      - name: Upload configs
        if: ${{ inputs.prepare_environment }}
        uses: appleboy/scp-action@v1
        with:
          host: ${{ inputs.host }}
          username: ${{ inputs.username }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ inputs.port }}
          source: ${{ steps.upload_paths.outputs.paths }}
          target: ${{ inputs.deployment_path }}
          command_timeout: 1m

      - name: Checking if the repo was just initialized
        id: previously_initialized
        run: |
          RAW=$(printf %s "${{ steps.initialize.outputs.stdout }}")
          RESULT=$(echo "$RAW" | grep -o '<<<OUTPUT::[01]>>>' | tail -n1 | sed -E 's/<<<OUTPUT::([01])>>>/\1/')
          echo "result=$RESULT" >> "$GITHUB_OUTPUT"

      - name: Connect and deploy
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ inputs.host }}
          username: ${{ inputs.username }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ inputs.port }}
          command_timeout: 3m
          script: |
            # Making it more strict for the script to fail in case of an error
            set -eux;
            
            # Change into the directory
            cd ${{ inputs.deployment_path }}
            
            # Check if the repo was previously initialized
            INITALIZED="${{ steps.previously_initialized.outputs.result }}"

            cat _ci_environment.json
            
            # Always parse init_script from JSON
            INIT_SCRIPT=$(jq -r '.init_script // empty' _ci_environment.json)

            # Run init script if it's provided and it's a freshly initialized repo 
            if [ "$INITALIZED" = "0" ] && [ -n "$INIT_SCRIPT" ]; then
              echo "Repo is freshly initialized, running init script: $INIT_SCRIPT"
              bash "$INIT_SCRIPT"
            fi

            echo "Cleaning git"
            git clean -fd
            
            echo "Ensuring we are not on a deleted branch"
            git checkout --detach || true
            
            echo "Removing stale remote-tracking refs"
            git for-each-ref --format='%(refname)' refs/remotes/origin/ | while read ref; do
              if ! git ls-remote --exit-code origin "${ref#refs/remotes/origin/}" >/dev/null 2>&1; then
                echo "Deleting stale ref: $ref"
                git update-ref -d "$ref"
              fi
            done
            
            echo "Deleting local branches that no longer exist on origin"
            for branch in $(git for-each-ref --format='%(refname:short)' refs/heads/); do
              if ! git ls-remote --exit-code origin "refs/heads/$branch" >/dev/null 2>&1; then
                echo "Deleting stale local branch: $branch"
                git branch -D "$branch"
              fi
            done

            echo "Retrieving the latest updates"
            git fetch --prune

            # This part is commented because it doesn't work well - if there are any changes done, 
            # or some commits are ahead autodeployment will fail
            # if git show-ref -q --verify "refs/heads/${{ inputs.ref }}" 2>/dev/null; then
            #   echo "Branch detected, switching and pulling"
            #   git checkout ${{ inputs.ref }}
            #   git pull
            # else
            #   echo "Non-branch detected, performing get reset"
            
            echo "Checking if it's a pull request"
            ref="${{ inputs.ref }}"
            if [[ ${{ inputs.ref }} =~ ^refs/pull/[0-9]+/merge$ ]]; then
              echo "Pull request detected"
              # Handling pull requests
              echo "Performing hard reset"
              git reset --hard
              echo "Switching to PR branch with detached HEAD"
              git fetch -u origin pull/${{ github.event.pull_request.number }}/head && git checkout FETCH_HEAD
            else
              echo "Pull request not detected"
              echo "Checking if remote branch exists"
              # This is just regular branch
              branch_exists="$(git ls-remote --heads origin "$ref" | wc -l)"

              if [[ "$branch_exists" -gt 0 ]]; then
                echo "Remote branch $ref exists, performing hard reset to it"
            
                # Force-create the remote-tracking branch
                git fetch origin "$ref:refs/remotes/origin/$ref"

                git reset --hard "origin/$ref"
              else
                echo "Remote branch $ref not found, performing hard reset"
                git reset --hard $ref
              fi
            fi
            
            # TODO Add compatibility with `docker compose` as well

            if [[ ${{ inputs.mode }} = "build" ]]; then
              # Rebuild docker image
              echo "Rebuilding Docker image"
              ./task.sh build
            elif [[ ${{ inputs.mode }} = "pull" ]]; then
              # Pull latest image
              echo "Rebuilding Docker image"
              # TODO Switch to task.sh
              docker compose pull
            fi
            
            echo "Stopping Docker Services"
            ./task.sh down
            
            echo "Starting Docker Services"
            ./task.sh up -d ${{ inputs.docker_up_args }}
            
            rm -f auth.json
            if [ -f "composer.json" ]; then
              echo "Installing composer dependencies"
              ./task.sh composer config --auth github-oauth.github.com ${{ secrets.UNIQUES_GITHUB_ACCESS_TOKEN }}
              ./task.sh composer install --no-dev
            fi
            rm -f auth.json
            
            rm -f .npmrc
            if [ -f "package.json" ]; then
              echo "Preparing .npmrc file"
              echo "@uniquesca:registry=https://npm.pkg.github.com/" > .npmrc
              echo "//npm.pkg.github.com/:_authToken=${{ secrets.NODE_AUTH_TOKEN }}" >> .npmrc
              echo "always-auth=true" >> .npmrc
            
              if [ -f "yarn.lock" ]; then
                echo "Installing Yarn"
                ./task.sh yarn install
              else 
                echo "Installing NPM"
                ./task.sh npm install
              fi
            fi
            rm -f .npmrc
            
            if ./task.sh supports migrate > /dev/null; then
              echo "Running migrations"
              ./task.sh migrate
            fi

            if ./task.sh supports clear-cache > /dev/null; then
              echo "Clearing cache"
              ./task.sh clear-cache
            fi
            
            echo "Executing post-deployment command"
            ${{ inputs.post_cmd }}
