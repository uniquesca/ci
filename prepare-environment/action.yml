name: Prepare environment config

inputs:
  working_directory:
    description: 'Working directory for this action, defaults to the current worker directory'
    required: false
    default: '.'
  env_file:
    description: 'Path to environment file. This has higher priority than the one defined in the CI environment config.'
    required: false
  env_file_stub:
    description: 'Path to environment stub file. This has higher priority than the one defined in the CI environment config.'
    required: false
  env_variables:
    description: 'JSON string object with information about variables and mappings. See more in the documentation.'
    required: true

runs:
  using: "composite"
  steps:
    - name: Get env file stub path
      id: env_file_stub
      shell: bash
      working-directory: ${{ inputs.working_directory }}
      run: |
        ENV_FILE_STUB="${{ inputs.env_file_stub }}"
    
        if [ -z "$ENV_FILE_STUB" ]; then
          echo "⚠️ Input env_file_stub is empty, checking _ci_environment.json"
        
          if [ ! -f "_ci_environment.json" ]; then
            echo "❌ Error: env_file_stub not provided and _ci_environment.json file not found"
            exit 1
          fi

          # Try to read env_file_stub property
          ENV_FILE_STUB=$(jq -r '.env_file_stub // empty' _ci_environment.json)
    
          if [ -z "$ENV_FILE_STUB" ]; then
            echo "❌ Error: env_file_stub property not found in _ci_environment.json"
            exit 1
          fi

          echo "✅ Using env_file_stub from _ci_environment.json: $ENV_FILE_STUB"
        else
          echo "✅ Using env_file_stub from input: $ENV_FILE_STUB"
        fi
        
        # Also set as output
        echo "env_file_stub=$ENV_FILE_STUB" >> $GITHUB_OUTPUT

    - name: Get env file path
      id: env_file
      shell: bash
      working-directory: ${{ inputs.working_directory }}
      run: |
        ENV_FILE="${{ inputs.env_file }}"
        
        if [ -z "$ENV_FILE" ]; then
          echo "⚠️ Input env_file is empty, checking _ci_environment.json"
        
          if [ ! -f "_ci_environment.json" ]; then
            echo "❌ Error: env_file not provided and _ci_environment.json file not found"
            exit 1
          fi

          # Try to read env_file property
          ENV_FILE=$(jq -r '.env_file // empty' _ci_environment.json)
        
          if [ -z "$ENV_FILE" ]; then
            echo "❌ Error: env_file property not found in _ci_environment.json"
            exit 1
          fi

          echo "✅ Using env_file from _ci_environment.json: $ENV_FILE"
        else
          echo "✅ Using env_file from input: $ENV_FILE"
        fi
        
        # Also set as output
        echo "env_file=$ENV_FILE" >> $GITHUB_OUTPUT

    - name: Prepare variables - applying fallbacks
      shell: bash
      working-directory: ${{ inputs.working_directory }}
      run: |
        VARIABLES='${{ inputs.env_variables }}'
    
        # Validate variables input
        echo "$VARIABLES" | jq empty || { echo "❌ env_variables is not valid JSON"; exit 1; }

        # Load environment JSON
        ENVIRONMENT=$(cat _ci_environment.json)
        FALLBACKS=$(echo "$ENVIRONMENT" | jq -r '.token_fallbacks // empty | to_entries[] | @base64')
    
        for ENTRY in $FALLBACKS; do
          KEY=$(echo "$ENTRY" | base64 --decode | jq -r '.key')
          FALLBACK=$(echo "$ENTRY" | base64 --decode | jq -r '.value')
        
          # Skip if variable is already defined
          if echo "$VARIABLES" | jq -e --arg K "$KEY" 'has($K)' >/dev/null; then
            continue
          fi
      
          if [[ "$FALLBACK" == \$* ]]; then
            # Fallback points to another variable
            REFERENCE="${FALLBACK:1}"
            if ! echo "$VARIABLES" | jq -e --arg R "$REFERENCE" 'has($R)' >/dev/null; then
              echo "Error: Referenced variable $REFERENCE is not found." >&2
              exit 1
            fi
            REF_VALUE=$(echo "$VARIABLES" | jq -r --arg R "$REFERENCE" '.[$R]')
            VARIABLES=$(echo "$VARIABLES" | jq --arg K "$KEY" --arg V "$REF_VALUE" '.[$K]=$V')
          else
            # Fallback is a literal value
            VARIABLES=$(echo "$VARIABLES" | jq --arg K "$KEY" --arg V "$FALLBACK" '.[$K]=$V')
          fi
        done
        
        # Convert dot notation to nested objects
        echo "✅ Converting dot notation to nested objects..."
        VARIABLES=$(echo "$VARIABLES" | jq '
          reduce (to_entries[] | select(.key | contains("."))) as $item (
            .;
            ($item.key | split(".")) as $path |
            setpath($path; $item.value) |
            del(.[$item.key])
          )
        ')
        
        # Debug variables
        if [[ "${RUNNER_DEBUG:-0}" == "1" ]]; then
          echo "$VARIABLES" | jq '.'
        fi
        
        echo "$VARIABLES" > __variables.json

    - name: Process config with Jinja2
      uses: cuchi/jinja2-action@v1.3.0
      working-directory: ${{ inputs.working_directory }}
      with:
        template: ${{ steps.env_file_stub.outputs.env_file_stub }}
        output_file: ${{ steps.env_file.outputs.env_file }}
        data_file: __variables.json
        data_format: json

    - name: Cleanup variables
      working-directory: ${{ inputs.working_directory }}
      if: always()
      shell: bash
      run: rm __variables.json