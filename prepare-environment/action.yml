name: Process multiple config templates

on:
  workflow_call:
inputs:
  working_directory:
    description: 'Working directory for this action, defaults to the current worker directory'
    required: false
    default: "."
  env_variables:
    description: 'JSON string object with information about variables and mappings. See more in the documentation.'
    required: true


runs:
  using: "composite"

  steps:
    - name: Install Jinja2 CLI
      shell: bash
      working-directory: ${{ inputs.working_directory }}
      run: |
        if [ ! -f _ci_environment.json ]; then
          echo "No CI envornment file — skipping composite action"
          exit 0
        fi
        pip install jinja2-cli[yaml,json]

    - name: Prepare variables - applying fallbacks
      id: prepare-variables
      shell: bash
      working-directory: ${{ inputs.working_directory }}
      run: |       
        VARIABLES='${{ inputs.env_variables }}'
        
        # Validate variables input
        echo "$VARIABLES" | jq empty || { echo "❌ env_variables is not valid JSON"; exit 1; }

        # Handling fallbacks if defined
        if [ -f _ci_environment.json ]; then
          # Load environment JSON only if file exists
          ENVIRONMENT=$(cat _ci_environment.json)
          FALLBACKS=$(echo "$ENVIRONMENT" | jq -r '.token_fallbacks // empty | to_entries[] | @base64')
          
          # WARNING: AI says this will cause an issue if values have spaces
          for ENTRY in $FALLBACKS; do
            KEY=$(echo "$ENTRY" | base64 --decode | jq -r '.key')
            FALLBACK=$(echo "$ENTRY" | base64 --decode | jq -r '.value')
          
            # Skip if variable is already defined
            if echo "$VARIABLES" | jq -e --arg K "$KEY" 'has($K)' >/dev/null; then
              continue
            fi
          
            if [[ "$FALLBACK" == \$* ]]; then
              # Fallback points to another variable
              REFERENCE="${FALLBACK:1}"
              if ! echo "$VARIABLES" | jq -e --arg R "$REFERENCE" 'has($R)' >/dev/null; then
                echo "Error: Referenced variable $REFERENCE is not found." >&2
                exit 1
              fi
              REF_VALUE=$(echo "$VARIABLES" | jq -r --arg R "$REFERENCE" '.[$R]')
              VARIABLES=$(echo "$VARIABLES" | jq --arg K "$KEY" --arg V "$REF_VALUE" '.[$K]=$V')
              echo "Adding fallback variable $KEY pointing to $REFERENCE"
            else
              # Fallback is a literal value
              VARIABLES=$(echo "$VARIABLES" | jq --arg K "$KEY" --arg V "$FALLBACK" '.[$K]=$V')
              echo "Adding fallback variable $KEY"
            fi
          done
        fi
        
        # Convert dot notation to nested objects
        echo "✅ Converting dot notation to nested objects..."
        VARIABLES=$(echo "$VARIABLES" | jq '
          reduce (to_entries[] | select(.key | contains("."))) as $item (
            .;
            ($item.key | split(".")) as $path |
            setpath($path; $item.value) |
            del(.[$item.key])
          )
        ')

        echo "$VARIABLES" > __variables.json

    - name: Process configs
      shell: bash
      working-directory: ${{ inputs.working_directory }}
      run: |
        if [ ! -f _ci_environment.json ]; then
          exit 0
        fi
        
        if [ ! -f __variables.json ]; then
          echo "❌ Variables file not found."
          exit 1
        fi
        
        jq -c '.configs[]?' _ci_environment.json | while read -r cfg; do
          STUB=$(echo "$cfg" | jq -r '.stub')
          DEST=$(echo "$cfg" | jq -r '.path')

          echo " ⏩ Jinja2: processing $STUB -> $DEST"

          # Process template with JSON variables
          jinja2 -o "$DEST" -f json "$STUB" __variables.json
        done

    - name: Cleanup
      if: ${{ always() }}
      working-directory: ${{ inputs.working_directory }}
      shell: bash
      run: |
        if [  -f __variables.json ]; then
          rm __variables.json -r
        fi
